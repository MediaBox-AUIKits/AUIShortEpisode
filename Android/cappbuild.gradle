import java.util.zip.CRC32
import java.util.zip.CheckedOutputStream
import java.util.zip.ZipEntry
import java.util.zip.ZipOutputStream

apply plugin: 'com.android.application'

android {
    flavorDimensions 'player'
    productFlavors {
        demo {
            dimension 'player'
            signingConfig signingConfigs.debug
            minSdkVersion androidMinSdkVersion
            targetSdkVersion androidTargetSdkVersion
            compileSdkVersion androidCompileSdkVersion
            ndk {
                abiFilters "armeabi-v7a", "arm64-v8a"
            }
        }
    }
}

ext {
//监听打包
    DEMO_FOLDER_NAME = 'AlivcPlayerSolution_Android'
    PATH_ZIP = File.separator + "outZip"
    PATH_BASE = File.separator + DEMO_FOLDER_NAME
    SRC_PATH = getRootDir().path
    DST_PATH = SRC_PATH + PATH_BASE
    OUT_ZIP_PATH = SRC_PATH + PATH_ZIP + File.separator + DEMO_FOLDER_NAME + '.zip'
}

getGradle().addBuildListener(new BuildListener() {
    boolean generateZip = false;

    @Override
    void settingsEvaluated(Settings settings) {

    }

    @Override
    void projectsLoaded(Gradle gradle) {

    }

    @Override
    void projectsEvaluated(Gradle gradle) {
        println "*************** projectsEvaluated *****************"
        if (project.hasProperty("czip") && "1".equals(czip)) {
            generateZip = true;
        }

        if (generateZip) {
            println "*************** startOutZip *****************"
            //删除out文件夹下的内容
            delete ext.DST_PATH;
            //删除outZip文件夹下所有的zip文件
            delete ext.OUT_ZIP_PATH
        }
    }

    @Override
    void buildFinished(BuildResult result) {
        println "*************** buildFinished *****************"
        if (generateZip) {
            // 如果需要执行源码包构建操作，直接在原工程上去除内网maven image，然后进行apk打包
            // 这样，当项目中存在外网拉不到的依赖时，打包会报错，便于发现问题
            removeTestCode(ext.SRC_PATH)
            copyModule()
        }

    }
})

/** 删除测试代码 */
static void removeTestCode(String projectPath) {
    def gradleFiles = new ArrayList<File>()
    new File(projectPath).eachFileRecurse(groovy.io.FileType.FILES) {
        if (it.isFile() && it.name.endsWith('.gradle')) {
            gradleFiles.add(it)
        }
    }

    def TEST_CODE_TAG = '//内部调试代码，发布删除 -- 注释勿动'
    gradleFiles.findAll { f ->
        f != null && f.text != null && f.text.contains(TEST_CODE_TAG)
    }.each { f ->
        def newText = ''
        f.readLines().findAll { line ->
            !line.trim().endsWith(TEST_CODE_TAG)
        }.each { line ->
            newText += "${line}\n"
        }
        f.text = newText
    }
}

void copyModule() {
    def mainPath = getProject().getProjectDir().getAbsolutePath();
    def mainName = getProject().getName();
    def animGradleScriptPath = ext.DST_PATH + File.separator + mainName
    copy {
        from ext.SRC_PATH
        into ext.DST_PATH
        exclude ".idea"
        exclude ".gradle"
        exclude "out"
        exclude "outZip"
        exclude "**.sh"
        exclude "**.py"
        exclude "cappbuild.gradle"
    }

    copy {
        from mainPath + File.separator + "build.gradle"
        into animGradleScriptPath
        filter { String line -> line.trim().startsWith("apply from: '../cappbuild.gradle'") ? null : line }
    }

    compress(ext.DST_PATH, ext.OUT_ZIP_PATH)
}

void compress(String srcPath, String dstPath) throws IOException {
    File srcFile = new File(srcPath);
    File dstFile = new File(dstPath);
    if (!srcFile.exists()) {
        throw new FileNotFoundException(srcPath + "不存在！");
    }
    if (!dstFile.exists()) {
        dstFile.parentFile.mkdirs()
    }
    FileOutputStream out = null;
    ZipOutputStream zipOut = null;
    try {
        out = new FileOutputStream(dstFile);
        CheckedOutputStream cos = new CheckedOutputStream(out, new CRC32());
        zipOut = new ZipOutputStream(cos);
        String baseDir = "";
        compress(srcFile, zipOut, baseDir);
    }
    finally {
        if (null != zipOut) {
            zipOut.close();
            out = null;
        }

        if (null != out) {
            out.close();
        }
    }
}

void compress(File file, ZipOutputStream zipOut, String baseDir) throws IOException {
    if (file.isDirectory()) {
        compressDirectory(file, zipOut, baseDir);
    } else {
        compressFile(file, zipOut, baseDir);
    }
}

/** 压缩一个目录 */
void compressDirectory(File dir, ZipOutputStream zipOut, String baseDir) throws IOException {
    File[] files = dir.listFiles();
    for (int i = 0; i < files.length; i++) {
        compress(files[i], zipOut, baseDir + dir.getName() + File.separator);
    }
}

/** 压缩一个文件 */
void compressFile(File file, ZipOutputStream zipOut, String baseDir) throws IOException {
    if (!file.exists()) {
        return;
    }
    BufferedInputStream bis = null;
    try {
        bis = new BufferedInputStream(new FileInputStream(file));
        ZipEntry entry = new ZipEntry(baseDir + file.getName());
        zipOut.putNextEntry(entry);
        int count;
        byte[] data = new byte[8192];
        while ((count = bis.read(data, 0, 8192)) != -1) {
            zipOut.write(data, 0, count);
        }

    } finally {
        if (null != bis) {
            bis.close();
        }
    }
}
